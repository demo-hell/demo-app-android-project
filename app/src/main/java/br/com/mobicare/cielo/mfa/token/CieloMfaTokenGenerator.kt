package br.com.mobicare.cielo.mfa.tokenimport android.security.keystore.KeyPropertiesimport android.security.keystore.KeyProtectionimport android.util.Pairimport br.com.mobicare.cielo.BuildConfig.OTP_BIT_3_MASKimport br.com.mobicare.cielo.BuildConfig.OTP_BIT_MASK_7import br.com.mobicare.cielo.BuildConfig.OTP_BIT_MASK_Fimport br.com.mobicare.cielo.BuildConfig.OTP_FULL_BYTE_MASKimport br.com.mobicare.cielo.BuildConfig.OTP_SHIFT_24_MASKimport br.com.mobicare.cielo.BuildConfig.OTP_SUBSECTION_MASKimport br.com.mobicare.cielo.commons.constants.EIGHTimport br.com.mobicare.cielo.commons.constants.ONEimport br.com.mobicare.cielo.commons.constants.ONE_THOUSANDimport br.com.mobicare.cielo.commons.constants.SIXimport br.com.mobicare.cielo.commons.constants.THIRTYimport br.com.mobicare.cielo.commons.constants.THREEimport br.com.mobicare.cielo.commons.constants.TWOimport br.com.mobicare.cielo.commons.constants.ZEROimport br.com.mobicare.cielo.commons.constants.ZERO_LONGimport br.com.mobicare.cielo.commons.data.clients.api.ServicesBaseimport br.com.mobicare.cielo.commons.data.clients.local.UserPreferencesimport br.com.mobicare.cielo.commons.data.clients.local.UserPreferences.Companion.MFA_SERVER_TIMEimport br.com.mobicare.cielo.commons.data.managers.APICallbackDefaultimport br.com.mobicare.cielo.commons.utils.crashlytics.logFirebaseCrashlyticsimport br.com.mobicare.cielo.featureToggle.data.clients.FeatureTogglePreferenceimport br.com.mobicare.cielo.featureToggle.data.clients.FeatureTogglePreference.Companion.LOCAL_DATE_DIFFERENCEimport br.com.mobicare.cielo.mfa.MfaEligibilityResponseimport br.com.mobicare.cielo.mfa.MfaRepositoryimport org.apache.commons.codec.binary.Base32import timber.log.Timberimport java.nio.ByteBufferimport java.nio.ByteOrderimport java.security.KeyStoreimport java.util.UUIDimport javax.crypto.Macimport javax.crypto.SecretKeyimport javax.crypto.spec.SecretKeySpecprivate const val ALGORITHM = "HmacSHA256"private const val ANDROID_KEY_STORE = "AndroidKeyStore"private const val ALPHABET_COMBINATION = "0123456789"private const val OLD_SEED_PATTERN = "::"/** * CieloMfaTokenGenerator is a way for generating one-time password (OTP) codes * based on the Mobile Financial Authorization (MFA) system. * The idea is to replace the old library called "OTP" * * @property mTokenPeriod The period, in seconds, for which each generated OTP code is valid. * @property mPeriodStart The timestamp indicating when the token generation started. * @property mMac An instance of Mac for cryptographic operations. */class CieloMfaTokenGenerator(    private val userPreferences: UserPreferences,    private val featureTogglePreference: FeatureTogglePreference,    private val mfaRepository: MfaRepository? = null) {    private var mTokenPeriod = THIRTY    private var mPeriodStart = ZERO_LONG    private val mMac = Mac.getInstance(ALGORITHM)    /**     * Parses the provided seed into a SecretKey and CieloMfaTokenGenerator instance.     *     * @param seed The seed string in the correct pattern to be parsed.     * @return A Pair containing the SecretKey and the current instance if parsing is successful, else null.     */    private fun parse(seed: String?): Pair<SecretKey, CieloMfaTokenGenerator>? {        seed?.let {            return try {                val bytes = Base32().decode(seed)                Pair(SecretKeySpec(bytes, ALGORITHM), this)            } catch (e: Exception) {                e.message.logFirebaseCrashlytics()                null            }        }        return null    }    /**     * Generates an OTP code based on the provided code.     *     * @param inputCode The input code used to generate the OTP.     * @return The generated OTP code as a string.     */    private fun makeOtpCode(inputCode: Int): String {        var code = inputCode        val buffer = CharArray(SIX)        val alphabet = ALPHABET_COMBINATION.toCharArray()        for (i in ZERO until SIX) {            buffer[SIX - i - ONE] = alphabet[code % alphabet.size]            code /= alphabet.size        }        return String(buffer)    }    /**     * Adds the provided SecretKey entry to the Android KeyStore.     *     * @param key The SecretKey entry to be added.     */    private fun addEntryOnKeyStore(key: SecretKey?) {        key?.apply {            val keyStore = KeyStore.getInstance(ANDROID_KEY_STORE)            keyStore.load(null)            keyStore.setEntry(                UUID.randomUUID().toString(), KeyStore.SecretKeyEntry(this@apply),                KeyProtection.Builder(KeyProperties.PURPOSE_SIGN).build()            )        }    }    /**     * Retrieves the OTP code based on the provided seed.     *     * @param seed The seed used to generate the OTP code.     * @param shouldManipulateTime If true, adjusts the time during the first OTP call to avoid repeating codes. Otherwise, uses the server time.     * @return The generated OTP code as a 6-digit string.     */    fun getOtpCode(seed: String?, shouldManipulateTime: Boolean = false): String? {        if (seedHasCorrectPattern(seed).not()) return null        try {            val key = parse(seed)?.first ?: return null            addEntryOnKeyStore(key)            getCurrentTimeFromMfaServer()            val mac = Mac.getInstance(ALGORITHM).apply { init(key) }            return with(ByteBuffer.allocate(EIGHT)) {                order(ByteOrder.BIG_ENDIAN)                putLong(getDesiredTime(shouldManipulateTime) / ONE_THOUSAND / THIRTY)                val digest = mac.doFinal(array())                val off = digest[digest.size - ONE].toInt() and OTP_BIT_MASK_F                var code = (digest[off].toInt() and OTP_BIT_MASK_7) shl OTP_SHIFT_24_MASK                code = code or ((digest[off + ONE].toInt() and OTP_FULL_BYTE_MASK) shl OTP_SUBSECTION_MASK)                code = code or ((digest[off + TWO].toInt() and OTP_FULL_BYTE_MASK) shl OTP_BIT_3_MASK)                code = code or (digest[off + THREE].toInt() and OTP_FULL_BYTE_MASK)                makeOtpCode(code)            }        } catch (e: Exception) {            Timber.e(e)            e.message?.logFirebaseCrashlytics()            return null        }    }    /**     * This function adjusts the time to handle discrepancies between the device time and the server time.     * Such discrepancies can lead to errors, such as INVALID_OTP_CODE.     *     * If the 'local_date_difference' feature toggle is enabled (true), the function retrieves the 'MFA_SERVER_TIME' value from user preferences.     * This value represents the time difference between the device and the server and is used to adjust the time during OTP generation.     * @param shouldManipulateTime If true, adjusts the time during the first OTP call to avoid repeating codes. Otherwise, uses the server time.     * @return The current time in milliseconds.     * If the 'local_date_difference' feature toggle is enabled, the returned time is adjusted to match the server time.     * Otherwise, the function returns the current device time.     */    private fun getDesiredTime(shouldManipulateTime: Boolean): Long {        val shouldCaptureMfaServerTime = featureTogglePreference.getFeatureTogle(LOCAL_DATE_DIFFERENCE)        val currentTime = System.currentTimeMillis()        return if (shouldCaptureMfaServerTime) {            val serverTime = userPreferences.get(MFA_SERVER_TIME, ZERO_LONG, true)            val timeDifference = serverTime - currentTime            val modifiedTime = currentTime + timeDifference            if (shouldManipulateTime) modifiedTime - 2000 else modifiedTime        } else {            currentTime        }    }    /**     * Make a call to the eligibility API to get the current time from the server and sync it with the device time.     * After the call is concluded, it will be intercepted by [ServicesBase.getMfaServerDateTime] and the time will be stored in the shared preferences     * to be recovered later by [getDesiredTime]. This is the only way to guarantee that the time is always synchronized.     */    private fun getCurrentTimeFromMfaServer() {        mfaRepository?.checkEligibility(object :            APICallbackDefault<MfaEligibilityResponse, String> {            override fun onSuccess(response: MfaEligibilityResponse) {}        })    }    companion object {        /**         * Checks if the provided seed adheres to the correct pattern.         * Ideally, the new seed pattern should be: GRXV J2PQ O5BT MUCP N5RX E4BZ TDPX OLVT.         * However, to be flexible to changes, we validate the correct pattern if the seed does not start with ::         *         * @param seed The seed string to be checked.         * @return True if the seed matches the correct pattern, else false.         */        fun seedHasCorrectPattern(seed: String?): Boolean {            return seed?.startsWith(OLD_SEED_PATTERN)?.not() ?: false        }    }}